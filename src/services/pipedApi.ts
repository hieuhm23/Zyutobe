// Piped API Service - YouTube Alternative API
// Docs: https://docs.piped.video/

// Danh sách server được chọn lọc kỹ cho Mobile
const PIPED_INSTANCES = [
    'https://pipedapi.kavin.rocks', // Main - Thường ổn định nhất
    'https://api.piped.yt',         // Official
    'https://pipedapi.tokhmi.xyz',  // Ít bị chặn
    'https://pipedapi.soopy.moe',
    'https://pipedapi.moomoo.me',
    'https://pipedapi.syncpundit.io',
    'https://piped-api.lunar.icu',
    'https://pa.il.ax',
];

let currentInstance = PIPED_INSTANCES[0];

// Types
export interface VideoItem {
    url: string;
    title: string;
    thumbnail: string;
    uploaderName: string;
    uploaderUrl: string;
    uploaderAvatar: string;
    uploadedDate: string;
    duration: number;
    views: number;
    uploaded: number;
    uploaderVerified: boolean;
    isShort: boolean;
}

export interface StreamInfo {
    title: string;
    description: string;
    uploadDate: string;
    uploader: string;
    uploaderUrl: string;
    uploaderAvatar: string;
    thumbnailUrl: string;
    duration: number;
    views: number;
    likes: number;
    dislikes: number;
    uploaderSubscriberCount: number;
    videoStreams: StreamSource[];
    audioStreams: StreamSource[];
    relatedStreams: VideoItem[];
    subtitles: Subtitle[];
    livestream: boolean;
    category: string;
    hls?: string;
}

export interface StreamSource {
    url: string;
    format: string;
    quality: string;
    mimeType: string;
    codec: string;
    videoOnly?: boolean;
    bitrate?: number;
    initStart?: number;
    initEnd?: number;
    indexStart?: number;
    indexEnd?: number;
    width?: number;
    height?: number;
    fps?: number;
}

export interface Subtitle {
    url: string;
    mimeType: string;
    name: string;
    code: string;
    autoGenerated: boolean;
}

export interface SearchResult {
    items: VideoItem[];
    nextpage: string;
    suggestion: string;
    corrected: boolean;
}

export interface TrendingItem extends VideoItem { }

// Helper function to handle API calls with fallback
async function fetchWithFallback(endpoint: string): Promise<any> {
    const instancesToTry = [currentInstance, ...PIPED_INSTANCES.filter(i => i !== currentInstance)];

    for (const instance of instancesToTry) {
        try {
            console.log(`Trying: ${instance}${endpoint}`);

            const controller = new AbortController();
            const timeoutId = setTimeout(() => controller.abort(), 12000); // 12s timeout

            const response = await fetch(`${instance}${endpoint}`, {
                signal: controller.signal,
                headers: {
                    'Accept': 'application/json',
                    // User-Agent giả lập iPhone thật để server tin tưởng
                    'User-Agent': 'Mozilla/5.0 (iPhone; CPU iPhone OS 16_0 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/16.0 Mobile/15E148 Safari/604.1',
                }
            });

            clearTimeout(timeoutId);

            if (response.ok) {
                console.log(`✅ Success: ${instance}`);
                currentInstance = instance;
                return await response.json();
            } else {
                console.log(`⚠️ Error ${response.status} from ${instance}`);
            }
        } catch (error: any) {
            console.log(`❌ Fail ${instance}: ${error.message}`);
        }
    }
    throw new Error('Không thể kết nối đến server video nào. Vui lòng kiểm tra mạng của bạn.');
}

// API Functions
export const pipedApi = {
    // Search videos
    search: async (query: string, filter: string = 'videos'): Promise<SearchResult> => {
        const encoded = encodeURIComponent(query);
        return fetchWithFallback(`/search?q=${encoded}&filter=${filter}`);
    },

    // Search next page
    searchNextPage: async (query: string, nextpage: string, filter: string = 'videos'): Promise<SearchResult> => {
        const encodedQuery = encodeURIComponent(query);
        const encodedNextpage = encodeURIComponent(nextpage);
        return fetchWithFallback(`/nextpage/search?q=${encodedQuery}&nextpage=${encodedNextpage}&filter=${filter}`);
    },

    // Get video/stream info
    getStream: async (videoId: string): Promise<StreamInfo> => {
        return fetchWithFallback(`/streams/${videoId}`);
    },

    // Get trending videos
    getTrending: async (region: string = 'VN'): Promise<TrendingItem[]> => {
        return fetchWithFallback(`/trending?region=${region}`);
    },

    // Get channel info
    getChannel: async (channelId: string): Promise<any> => {
        return fetchWithFallback(`/channel/${channelId}`);
    },

    // Get playlists
    getPlaylist: async (playlistId: string): Promise<any> => {
        return fetchWithFallback(`/playlists/${playlistId}`);
    },

    // Get suggestions
    getSuggestions: async (query: string): Promise<string[]> => {
        const encoded = encodeURIComponent(query);
        return fetchWithFallback(`/suggestions?query=${encoded}`);
    },

    // Get comments
    getComments: async (videoId: string): Promise<any> => {
        return fetchWithFallback(`/comments/${videoId}`);
    },

    // Helper: Extract video ID from URL
    extractVideoId: (url: string): string | null => {
        const watchMatch = url.match(/[?&]v=([^&]+)/);
        if (watchMatch) return watchMatch[1];
        const shortsMatch = url.match(/\/shorts\/([^/?]+)/);
        if (shortsMatch) return shortsMatch[1];
        if (url.length === 11 && !url.includes('/')) return url;
        return null;
    },

    // Helper: Format duration
    formatDuration: (seconds: number): string => {
        if (seconds < 0) return 'LIVE';
        const hrs = Math.floor(seconds / 3600);
        const mins = Math.floor((seconds % 3600) / 60);
        const secs = seconds % 60;
        if (hrs > 0) return `${hrs}:${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
        return `${mins}:${secs.toString().padStart(2, '0')}`;
    },

    // Helper: Format view count
    formatViews: (views: number): string => {
        if (views >= 1000000000) return (views / 1000000000).toFixed(1) + 'B';
        if (views >= 1000000) return (views / 1000000).toFixed(1) + 'M';
        if (views >= 1000) return (views / 1000).toFixed(1) + 'K';
        return views.toString();
    },

    getCurrentInstance: (): string => currentInstance,
};

export default pipedApi;
