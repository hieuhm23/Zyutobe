import { Alert } from 'react-native';

const PIPED_INSTANCES = [
    'https://pipedapi.kavin.rocks', // Official
    'https://api.piped.yt',          // Europe (Fast)
    'https://pipedapi.systemless.io', // US
    'https://api-piped.mha.fi',       // Finland
    'https://pipedapi.drgns.space',   // US West
    'https://pipedapi.tokhmi.xyz',    // Europe
    'https://pipedapi.ducks.party',
    'https://pipedapi.adminforge.de', // Germany
    'https://pipedapi.astartes.nl',   // Netherlands
    'https://pipedapi.smnz.de',
    'https://api.piped.privacy.com.de',
];

const COBALT_INSTANCES = [
    'https://api.cobalt.tools/api/json', // Official (Reliable)
    'https://co.wuk.sh/api/json',        // Popular Mirror
    'https://cobalt.steamodded.eu/api/json',
    'https://cobalt.xy24.eu/api/json',
    'https://api.cobalt.best/api/json',
    'https://cobalt.bepsh.d00.eu/api/json',
    'https://cobalt.q1.si/api/json'
];

export interface StreamResult {
    url: string;
    headers?: Record<string, string>;
}

const INVIDIOUS_INSTANCES = [
    'https://inv.tux.pizza',
    'https://invidious.drgns.space',
    'https://vid.puffyan.us',
    'https://invidious.jing.rocks',
    'https://invidious.nerdvpn.de'
];

export interface VideoItem {
    url: string;
    type: string;
    title: string;
    thumbnail: string;
    uploaderName: string;
    uploaderUrl?: string; // Added for compatibility
    uploaderAvatar?: string;
    uploaderVerified?: boolean; // Added
    uploadedDate?: string;
    uploaded?: number; // Added
    shortDescription?: string;
    duration?: number;
    views?: number;
    isShort?: boolean;
}

export interface StreamInfo {
    title: string;
    description: string;
    uploadDate: string;
    uploader: string;
    uploaderUrl?: string; // Added
    uploaderAvatar: string;
    thumbnailUrl: string;
    duration?: number; // Added
    hls: string | null;
    videoStreams: {
        url: string;
        format: string;
        quality: string;
        mimeType: string;
        codec: string;
        videoOnly: boolean;
        height?: number;
    }[];
    audioStreams: {
        url: string;
        format: string;
        quality: string;
        mimeType: string;
        codec: string;
    }[];
    relatedStreams: VideoItem[];
    relatedNextPageToken?: string | null;
    views: number;
}

// Compatibility Types for youtubeApi.ts
export interface StreamSource {
    url: string;
    format: string;
    quality: string;
    mimeType: string;
}
export interface Subtitle {
    url: string;
    mimeType: string;
    name: string;
    code: string;
    autoGenerated: boolean;
}
export interface SearchResult {
    items: VideoItem[];
    nextPageToken?: string;
}
export type TrendingItem = VideoItem;

// --- HELPER: Fast Fallback Request ---
async function fetchWithTimeout(url: string, options: any = {}, timeout = 5000) {
    const controller = new AbortController();
    const id = setTimeout(() => controller.abort(), timeout);
    try {
        const res = await fetch(url, { ...options, signal: controller.signal });
        clearTimeout(id);
        return res;
    } catch (e) {
        clearTimeout(id);
        throw e;
    }
}

class PipedApi {

    // --- WORKERS ---

    // 1. Cobalt (Best Quality)
    async tryCobalt(videoId: string): Promise<StreamResult | null> {
        for (const instance of COBALT_INSTANCES) {
            try {
                console.log(`Trying Cobalt: ${instance}`);
                const res = await fetchWithTimeout(instance, {
                    method: 'POST',
                    headers: { 'Accept': 'application/json', 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        url: `https://www.youtube.com/watch?v=${videoId}`,
                        vCodec: 'h264', vQuality: '720', isAudioOnly: false, aFormat: "mp3"
                    })
                }, 8000);
                const data = await res.json();
                const u = data.url || data.picker?.find((p: any) => p.type === 'video')?.url;
                if (u) return {
                    url: u,
                    headers: { 'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36' }
                };
            } catch (e) {
                console.log(`Cobalt ${instance} failed`);
            }
        }
        return null;
    }

    // 2. Piped (Reliable & Fast - Prefer MP4)
    async tryPiped(videoId: string): Promise<StreamResult | null> {
        const instances = [...PIPED_INSTANCES].sort(() => 0.5 - Math.random());

        for (const instance of instances) {
            try {
                const res = await fetchWithTimeout(`${instance}/streams/${videoId}`, {}, 5000);
                if (res.ok) {
                    const data = await res.json();

                    // Filter and sort video streams by height (quality)
                    const mp4Streams = (data.videoStreams || [])
                        .filter((s: any) => !s.videoOnly && s.mimeType.includes('mp4'))
                        .sort((a: any, b: any) => (b.height || 0) - (a.height || 0));

                    if (mp4Streams.length > 0) {
                        return {
                            url: mp4Streams[0].url,
                            headers: { 'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36' }
                        };
                    }

                    if (data.hls) return { url: data.hls };
                }
            } catch (e) { }
        }
        return null;
    }

    // 3. Invidious (Backup)
    async tryInvidious(videoId: string): Promise<StreamResult | null> {
        const instances = [...INVIDIOUS_INSTANCES].sort(() => 0.5 - Math.random());
        for (const instance of instances) {
            try {
                const res = await fetchWithTimeout(`${instance}/api/v1/videos/${videoId}`, {}, 5000);
                if (res.ok) {
                    const data = await res.json();
                    const mp4 = data.formatStreams?.find((s: any) => s.container === 'mp4');
                    if (mp4) return {
                        url: mp4.url,
                        headers: { 'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36' }
                    };
                }
            } catch (e: any) { }
        }
        return null;
    }

    // 4. NUCLEAR OPTION: YouTube Internal API (IOS Client - HLS)
    // DISABLED: expo-av on iOS fails to pass headers to HLS segments (-1102 Error)
    async tryIOSAPI(videoId: string): Promise<StreamResult | null> {
        const IOS_USER_AGENT = 'com.google.ios.youtube/19.45.4 (iPhone16,2; U; CPU iOS 18_1_0 like Mac OS X;)';
        try {
            console.log('Ô£ø Attempting IOS Internal API...');
            const res = await fetch(`https://youtubei.googleapis.com/youtubei/v1/player?key=AIzaSyB_1hJc69ar_8e1e7e_0y9e3p2_u3s6-4w`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'User-Agent': IOS_USER_AGENT,
                    'X-YouTube-Client-Name': '5',
                    'X-YouTube-Client-Version': '19.45.4'
                },
                body: JSON.stringify({
                    context: {
                        client: {
                            clientName: 'IOS',
                            clientVersion: '19.45.4',
                            deviceMake: 'Apple',
                            deviceModel: 'iPhone16,2',
                            network: 'WIFI',
                            osName: 'iPhone',
                            osVersion: '18.1.0'
                        }
                    },
                    videoId: videoId,
                    playbackContext: {
                        contentPlaybackContext: {
                            signatureTimestamp: 19747
                        }
                    }
                })
            });
            const data = await res.json();

            if (data.streamingData && data.streamingData.hlsManifestUrl) {
                return {
                    url: data.streamingData.hlsManifestUrl,
                    headers: {
                        'User-Agent': IOS_USER_AGENT,
                    }
                };
            }
        } catch (e) {
            console.log("IOS API Failed", e);
        }
        return null;
    }

    // 5. NUCLEAR OPTION: YouTube Internal API (Android Client - Progressive MP4)
    // Progressive MP4s are the most reliable direct links (no complex HLS/DASH handling)
    async tryAndroidAPI(videoId: string): Promise<StreamResult | null> {
        try {
            console.log('‚ò¢Ô∏è Attempting Android Internal API (Progressive)...');
            const res = await fetch(`https://youtubei.googleapis.com/youtubei/v1/player?key=AIzaSyB_1hJc69ar_8e1e7e_0y9e3p2_u3s6-4w`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'User-Agent': 'com.google.android.youtube/19.29.35 (Linux; U; Android 14; en_US) gzip',
                    'X-YouTube-Client-Name': '3',
                    'X-YouTube-Client-Version': '19.29.35'
                },
                body: JSON.stringify({
                    context: {
                        client: {
                            clientName: 'ANDROID',
                            clientVersion: '19.29.35',
                            androidSdkVersion: 34,
                            hl: 'en',
                            gl: 'VN'
                        }
                    },
                    videoId: videoId,
                    playbackContext: {
                        contentPlaybackContext: {
                            signatureTimestamp: 21442
                        }
                    }
                })
            });
            const data = await res.json();

            if (data.streamingData && data.streamingData.formats) {
                // progressive formats (usually 360p or 720p with audio included)
                // Filter for MP4
                const valid = data.streamingData.formats.find((f: any) => f.url && f.mimeType.includes('mp4'));
                if (valid) {
                    return {
                        url: valid.url,
                        // No specific headers needed for progressive Google links usually, 
                        // but playing it safe with a standard UA or none.
                        headers: { 'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36' }
                    };
                }
            }
        } catch (e) {
            console.log("Android API Failed", e);
        }
        return null;
    }

    // --- ORCHESTRATOR ---
    async getBestStreamUrl(videoId: string): Promise<StreamResult | null> {
        // 1. Android API (Fastest & Direct MP4)
        const android = await this.tryAndroidAPI(videoId);
        if (android) return android;

        // 2. Piped (Reliable Backup)
        const piped = await this.tryPiped(videoId);
        if (piped) return piped;

        // 3. Cobalt (Last resort for quality)
        const cobalt = await this.tryCobalt(videoId);
        if (cobalt) return cobalt;

        // 4. Invidious (Backup)
        const inv = await this.tryInvidious(videoId);
        if (inv) return inv;

        // Note: IOS API disabled due to player limitations with headers
        /*
        const ios = await this.tryIOSAPI(videoId);
        if (ios) { console.log('‚úÖ Found via IOS API'); return ios; }
        */

        // Note: Direct Android API extraction removed as it generates 403 Forbidden links
        // without complex signature deciphering.

        return null;
    }

    // --- AUDIO-ONLY MODE ---
    // Get best audio stream for Audio-Only mode (saves bandwidth)
    // OPTIMIZED: Uses Promise.race for faster loading
    async getBestAudioUrl(videoId: string): Promise<StreamResult | null> {
        console.log('üéµ Audio-Only: Starting parallel fetch...');

        // Helper for Cobalt audio
        const tryCobaltAudio = async (instance: string): Promise<StreamResult | null> => {
            try {
                const res = await fetchWithTimeout(instance, {
                    method: 'POST',
                    headers: { 'Accept': 'application/json', 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        url: `https://www.youtube.com/watch?v=${videoId}`,
                        isAudioOnly: true,
                        aFormat: 'mp3',
                        filenamePattern: 'basic'
                    })
                }, 4000); // Shorter timeout
                const data = await res.json();
                if (data.url) {
                    console.log('‚úÖ Audio-Only: Found via Cobalt');
                    return {
                        url: data.url,
                        headers: { 'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36' }
                    };
                }
            } catch (e) { }
            return null;
        };

        // Helper for Piped audio
        const tryPipedAudio = async (instance: string): Promise<StreamResult | null> => {
            try {
                const res = await fetchWithTimeout(`${instance}/streams/${videoId}`, {}, 3000);
                if (res.ok) {
                    const data = await res.json();
                    if (data.audioStreams && data.audioStreams.length > 0) {
                        const sorted = data.audioStreams.sort((a: any, b: any) => {
                            const aBitrate = parseInt(a.quality) || 0;
                            const bBitrate = parseInt(b.quality) || 0;
                            return bBitrate - aBitrate;
                        });
                        console.log('‚úÖ Audio-Only: Found via Piped');
                        return {
                            url: sorted[0].url,
                            headers: { 'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36' }
                        };
                    }
                }
            } catch (e) { }
            return null;
        };

        // Run all in parallel, return first success
        const allPromises: Promise<StreamResult | null>[] = [
            // Cobalt instances (faster for audio)
            ...COBALT_INSTANCES.slice(0, 3).map(inst => tryCobaltAudio(inst)),
            // Piped instances
            ...PIPED_INSTANCES.slice(0, 4).map(inst => tryPipedAudio(inst))
        ];

        // Race: Return first successful result
        const raceWithFilter = async (): Promise<StreamResult | null> => {
            const results = await Promise.allSettled(allPromises);
            for (const result of results) {
                if (result.status === 'fulfilled' && result.value) {
                    return result.value;
                }
            }
            return null;
        };

        // Set overall timeout of 5 seconds
        const timeoutPromise = new Promise<StreamResult | null>((resolve) =>
            setTimeout(() => resolve(null), 5000)
        );

        const result = await Promise.race([raceWithFilter(), timeoutPromise]);

        if (result) {
            return result;
        }

        // Fallback to video stream if audio not found
        console.log('‚ö†Ô∏è Audio-Only: Fallback to video stream');
        return this.getBestStreamUrl(videoId);
    }

    async search(query: string): Promise<VideoItem[]> {
        // Fallback search using Piped
        const instances = [...PIPED_INSTANCES].sort(() => 0.5 - Math.random());
        for (const instance of instances) {
            try {
                const res = await fetchWithTimeout(`${instance}/search?q=${encodeURIComponent(query)}&filter=all`, {}, 5000);
                const data = await res.json();
                if (!data.error) return data.items.map((item: any) => ({
                    url: item.url,
                    type: item.type,
                    title: item.title,
                    thumbnail: item.thumbnail,
                    uploaderName: item.uploaderName,
                    uploadedDate: item.uploadedDate,
                    duration: item.duration,
                    views: item.views,
                    isShort: item.duration < 60
                }));
            } catch (e) { }
        }
        return [];
    }

    async getStream(videoId: string): Promise<StreamInfo | null> {
        // Helper for legacy method compatibility (if used elsewhere)
        const instances = [...PIPED_INSTANCES].sort(() => 0.5 - Math.random());
        for (const instance of instances) {
            try {
                const res = await fetchWithTimeout(`${instance}/streams/${videoId}`);
                const data = await res.json();
                if (data && !data.error) return data;
            } catch (e) { }
        }
        return null;
    }

    async getTrending(): Promise<VideoItem[]> {
        const instances = [...PIPED_INSTANCES].sort(() => 0.5 - Math.random());
        for (const instance of instances) {
            try {
                const res = await fetchWithTimeout(`${instance}/trending?region=VN`);
                const data = await res.json();
                if (!data.error) return data.map((item: any) => ({
                    url: item.url,
                    type: item.type,
                    title: item.title,
                    thumbnail: item.thumbnail,
                    uploaderName: item.uploaderName,
                    uploadedDate: item.uploadedDate,
                    duration: item.duration,
                    views: item.views,
                    isShort: false
                }));
            } catch (e) { }
        }
        return [];
    }

    async getSuggestions(query: string): Promise<string[]> {
        const instances = [...PIPED_INSTANCES];
        for (const instance of instances) {
            try {
                const res = await fetchWithTimeout(`${instance}/suggestions?query=${encodeURIComponent(query)}`);
                const data = await res.json();
                if (Array.isArray(data)) return data;
            } catch (e) { }
        }
        return [];
    }

    formatDuration(seconds: number): string {
        if (!seconds) return '0:00';
        const h = Math.floor(seconds / 3600);
        const m = Math.floor((seconds % 3600) / 60);
        const s = Math.floor(seconds % 60);
        if (h > 0) return `${h}:${m.toString().padStart(2, '0')}:${s.toString().padStart(2, '0')}`;
        return `${m}:${s.toString().padStart(2, '0')}`;
    }

    formatViews(views: number): string {
        if (!views) return '0 views';
        if (views >= 1000000) return `${(views / 1000000).toFixed(1)}M views`;
        if (views >= 1000) return `${(views / 1000).toFixed(1)}K views`;
        return `${views} views`;
    }
}

export default new PipedApi();
