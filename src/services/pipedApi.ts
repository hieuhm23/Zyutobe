// Piped API Service - Stable & Image Fix
// Docs: https://docs.piped.video/

// Sử dụng server chính chủ giống web piped.video
const PIPED_INSTANCES = [
    'https://api.piped.yt',
    'https://pipedapi.kavin.rocks',
];

let currentInstance = PIPED_INSTANCES[0];

// Types
export interface VideoItem {
    url: string;
    title: string;
    thumbnail: string;
    uploaderName: string;
    uploaderUrl: string;
    uploaderAvatar: string;
    uploadedDate: string;
    duration: number;
    views: number;
    uploaded: number;
    uploaderVerified: boolean;
    isShort: boolean;
}

export interface StreamInfo {
    title: string;
    description: string;
    uploadDate: string;
    uploader: string;
    uploaderUrl: string;
    uploaderAvatar: string;
    thumbnailUrl: string;
    duration: number;
    views: number;
    likes: number;
    dislikes: number;
    uploaderSubscriberCount: number;
    videoStreams: StreamSource[];
    audioStreams: StreamSource[];
    relatedStreams: VideoItem[];
    subtitles: Subtitle[];
    livestream: boolean;
    category: string;
    hls?: string;
}

export interface StreamSource {
    url: string;
    format: string;
    quality: string;
    mimeType: string;
    codec: string;
    videoOnly?: boolean;
    bitrate?: number;
    initStart?: number;
    initEnd?: number;
    indexStart?: number;
    indexEnd?: number;
    width?: number;
    height?: number;
    fps?: number;
}

export interface Subtitle {
    url: string;
    mimeType: string;
    name: string;
    code: string;
    autoGenerated: boolean;
}

export interface SearchResult {
    items: VideoItem[];
    nextpage: string;
    suggestion: string;
    corrected: boolean;
}

export interface TrendingItem extends VideoItem { }

// Helper function to handle API calls with fallback
async function fetchWithFallback(endpoint: string): Promise<any> {
    const instancesToTry = [currentInstance, ...PIPED_INSTANCES.filter(i => i !== currentInstance)];

    for (const instance of instancesToTry) {
        try {
            console.log(`Connecting to: ${instance}...`);
            const controller = new AbortController();
            const timeoutId = setTimeout(() => controller.abort(), 15000); // 15s

            const response = await fetch(`${instance}${endpoint}`, {
                signal: controller.signal
            });
            clearTimeout(timeoutId);

            if (response.ok) {
                const text = await response.text();
                // Bỏ qua nếu trả về HTML lỗi
                if (text.trim().startsWith('<')) continue;
                try {
                    const json = JSON.parse(text);
                    currentInstance = instance;
                    return json;
                } catch (e) { continue; }
            }
        } catch (error) { console.log(`Error ${instance}`); }
    }
    throw new Error('Mạng quá yếu hoặc tất cả server đều bận.');
}

// API Functions
export const pipedApi = {
    // Search videos
    search: async (query: string, filter: string = 'videos'): Promise<SearchResult> => {
        const encoded = encodeURIComponent(query);
        const data = await fetchWithFallback(`/search?q=${encoded}&filter=${filter}`);
        // Fix ảnh thumbnail trực tiếp từ kết quả search
        if (data && data.items) {
            data.items.forEach((item: VideoItem) => {
                if (!item.thumbnail.startsWith('http')) {
                    // Nếu link ảnh tương đối, ghép với instance
                    item.thumbnail = item.thumbnail;
                }
            });
        }
        return data;
    },

    // Search next page
    searchNextPage: async (query: string, nextpage: string, filter: string = 'videos'): Promise<SearchResult> => {
        const encodedQuery = encodeURIComponent(query);
        const encodedNextpage = encodeURIComponent(nextpage);
        return fetchWithFallback(`/nextpage/search?q=${encodedQuery}&nextpage=${encodedNextpage}&filter=${filter}`);
    },

    // Get video/stream info
    getStream: async (videoId: string): Promise<StreamInfo> => {
        return fetchWithFallback(`/streams/${videoId}`);
    },

    // Get trending videos
    getTrending: async (region: string = 'VN'): Promise<TrendingItem[]> => {
        return fetchWithFallback(`/trending?region=${region}`);
    },

    // Get channel info
    getChannel: async (channelId: string): Promise<any> => {
        return fetchWithFallback(`/channel/${channelId}`);
    },

    // Get playlists
    getPlaylist: async (playlistId: string): Promise<any> => {
        return fetchWithFallback(`/playlists/${playlistId}`);
    },

    // Get suggestions
    getSuggestions: async (query: string): Promise<string[]> => {
        const encoded = encodeURIComponent(query);
        return fetchWithFallback(`/suggestions?query=${encoded}`);
    },

    // Get comments
    getComments: async (videoId: string): Promise<any> => {
        return fetchWithFallback(`/comments/${videoId}`);
    },

    // Helper: Extract video ID from URL
    extractVideoId: (url: string): string | null => {
        const watchMatch = url.match(/[?&]v=([^&]+)/);
        if (watchMatch) return watchMatch[1];
        const shortsMatch = url.match(/\/shorts\/([^/?]+)/);
        if (shortsMatch) return shortsMatch[1];
        if (url.length === 11 && !url.includes('/')) return url;
        return null;
    },

    formatDuration: (seconds: number): string => {
        if (seconds < 0) return 'LIVE';
        const hrs = Math.floor(seconds / 3600);
        const mins = Math.floor((seconds % 3600) / 60);
        const secs = seconds % 60;
        if (hrs > 0) return `${hrs}:${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
        return `${mins}:${secs.toString().padStart(2, '0')}`;
    },

    formatViews: (views: number): string => {
        if (views >= 1000000000) return (views / 1000000000).toFixed(1) + 'B';
        if (views >= 1000000) return (views / 1000000).toFixed(1) + 'M';
        if (views >= 1000) return (views / 1000).toFixed(1) + 'K';
        return views.toString();
    },

    getVideoUrl: (streamInfo: StreamInfo): string | undefined => {
        // 1. Luôn ưu tiên HLS (m3u8) để chạy mượt
        if (streamInfo.hls) return streamInfo.hls;

        // 2. Tìm mp4 có cả hình và tiếng
        const streams = streamInfo.videoStreams || [];
        const combinedStreams = streams.filter(s => !s.videoOnly);

        if (combinedStreams.length > 0) {
            return combinedStreams.sort((a, b) => (b.height || 0) - (a.height || 0))[0]?.url;
        }

        return streams[0]?.url;
    },

    getCurrentInstance: (): string => currentInstance,
};

export default pipedApi;
