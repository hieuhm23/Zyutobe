// Piped API Service - Headers Fix for Kavin
// Docs: https://docs.piped.video/

// Danh sách server - Ưu tiên Nhật Bản (gần VN nhất)
const PIPED_INSTANCES = [
    'https://ph.076.ne.jp',              // Japan -> Rất nhanh cho VN
    'https://pipedapi.kavin.rocks',      // Ổn định
    'https://pipedapi.adminforge.de',    // Germany
    'https://piped-api.garudalinux.org', // India/Global
    'https://api.piped.yt',              // Global
    'https://pipedapi.drgns.space',      // US
    'https://pipedapi.tokhmi.xyz',
    'https://pipedapi.smnz.de',
];

let currentInstance = PIPED_INSTANCES[0];

// Types
export interface VideoItem {
    url: string;
    title: string;
    thumbnail: string;
    uploaderName: string;
    uploaderUrl: string;
    uploaderAvatar: string;
    uploadedDate: string;
    duration: number;
    views: number;
    uploaded: number;
    uploaderVerified: boolean;
    isShort: boolean;
}

export interface StreamInfo {
    title: string;
    description: string;
    uploadDate: string;
    uploader: string;
    uploaderUrl: string;
    uploaderAvatar: string;
    thumbnailUrl: string;
    duration: number;
    views: number;
    likes: number;
    dislikes: number;
    uploaderSubscriberCount: number;
    videoStreams: StreamSource[];
    audioStreams: StreamSource[];
    relatedStreams: VideoItem[];
    subtitles: Subtitle[];
    livestream: boolean;
    category: string;
    hls?: string;
}

export interface StreamSource {
    url: string;
    format: string;
    quality: string;
    mimeType: string;
    codec: string;
    videoOnly?: boolean;
    bitrate?: number;
    initStart?: number;
    initEnd?: number;
    indexStart?: number;
    indexEnd?: number;
    width?: number;
    height?: number;
    fps?: number;
}

export interface Subtitle {
    url: string;
    mimeType: string;
    name: string;
    code: string;
    autoGenerated: boolean;
}

export interface SearchResult {
    items: VideoItem[];
    nextpage: string;
    suggestion: string;
    corrected: boolean;
}

export interface TrendingItem extends VideoItem { }

// Helper function to handle API calls with fallback
async function fetchWithFallback(endpoint: string): Promise<any> {
    const instancesToTry = [currentInstance, ...PIPED_INSTANCES.filter(i => i !== currentInstance)];

    for (const instance of instancesToTry) {
        try {
            console.log(`Connecting to: ${instance}...`);
            const controller = new AbortController();
            const timeoutId = setTimeout(() => controller.abort(), 12000); // 12s timeout

            // THÊM HEADERS ĐỂ FIX LỖI 500 TRÊN KAVIN.ROCKS
            const response = await fetch(`${instance}${endpoint}`, {
                signal: controller.signal,
                headers: {
                    'User-Agent': 'Mozilla/5.0 (iPhone; CPU iPhone OS 16_6 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/16.6 Mobile/15E148 Safari/604.1',
                    'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8',
                    'Accept-Language': 'en-US,en;q=0.9',
                    'Origin': 'https://piped.video',
                    'Referer': 'https://piped.video/'
                }
            });
            clearTimeout(timeoutId);

            if (response.ok) {
                const text = await response.text();
                // Bỏ qua nếu trả về HTML lỗi
                if (text.trim().startsWith('<')) {
                    console.log(`⚠️ HTML Error from ${instance}`);
                    continue;
                }
                try {
                    const json = JSON.parse(text);

                    // KIỂM TRA DỮ LIỆU CÓ HỢP LỆ KHÔNG?
                    // Nếu đang lấy stream mà không có link video -> Coi như lỗi server này
                    if (endpoint.includes('/streams/') && !json.hls && (!json.videoStreams || json.videoStreams.length === 0)) {
                        console.log(`⚠️ Data Incomplete from ${instance} (No Streams)`);
                        continue; // Thử server khác
                    }

                    console.log(`✅ DATA VALID: ${instance}`);
                    currentInstance = instance;
                    return json;
                } catch (e) { continue; }
            } else {
                console.log(`⚠️ Error ${response.status}: ${instance}`);
            }
        } catch (error: any) {
            console.log(`❌ Fail ${instance}:`, error.message);
        }
    }
    throw new Error('Không thể tải dữ liệu. Vui lòng kiểm tra lại Wifi/4G hoặc thử lại sau.');
}

// API Functions
export const pipedApi = {
    // Search videos
    search: async (query: string, filter: string = 'videos'): Promise<SearchResult> => {
        const encoded = encodeURIComponent(query);
        const data = await fetchWithFallback(`/search?q=${encoded}&filter=${filter}`);
        // Fix ảnh thumbnail trực tiếp từ kết quả search
        if (data && data.items) {
            data.items.forEach((item: VideoItem) => {
                if (!item.thumbnail.startsWith('http')) {
                    item.thumbnail = item.thumbnail;
                }
            });
        }
        return data;
    },

    // Search next page
    searchNextPage: async (query: string, nextpage: string, filter: string = 'videos'): Promise<SearchResult> => {
        const encodedQuery = encodeURIComponent(query);
        const encodedNextpage = encodeURIComponent(nextpage);
        return fetchWithFallback(`/nextpage/search?q=${encodedQuery}&nextpage=${encodedNextpage}&filter=${filter}`);
    },

    // Get video/stream info
    getStream: async (videoId: string): Promise<StreamInfo> => {
        return fetchWithFallback(`/streams/${videoId}`);
    },

    // Get trending videos
    getTrending: async (region: string = 'VN'): Promise<TrendingItem[]> => {
        try {
            return await fetchWithFallback(`/trending?region=${region}`);
        } catch (e) {
            return await fetchWithFallback(`/trending?region=US`);
        }
    },

    // Get channel info
    getChannel: async (channelId: string): Promise<any> => {
        return fetchWithFallback(`/channel/${channelId}`);
    },

    // Get playlists
    getPlaylist: async (playlistId: string): Promise<any> => {
        return fetchWithFallback(`/playlists/${playlistId}`);
    },

    // Get suggestions
    getSuggestions: async (query: string): Promise<string[]> => {
        const encoded = encodeURIComponent(query);
        return fetchWithFallback(`/suggestions?query=${encoded}`);
    },

    // Get comments
    getComments: async (videoId: string): Promise<any> => {
        return fetchWithFallback(`/comments/${videoId}`);
    },

    // Helper: Extract video ID from URL
    extractVideoId: (url: string): string | null => {
        const watchMatch = url.match(/[?&]v=([^&]+)/);
        if (watchMatch) return watchMatch[1];
        const shortsMatch = url.match(/\/shorts\/([^/?]+)/);
        if (shortsMatch) return shortsMatch[1];
        if (url.length === 11 && !url.includes('/')) return url;
        return null;
    },

    formatDuration: (seconds: number): string => {
        if (seconds < 0) return 'LIVE';
        const hrs = Math.floor(seconds / 3600);
        const mins = Math.floor((seconds % 3600) / 60);
        const secs = seconds % 60;
        if (hrs > 0) return `${hrs}:${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
        return `${mins}:${secs.toString().padStart(2, '0')}`;
    },

    formatViews: (views: number): string => {
        if (views >= 1000000000) return (views / 1000000000).toFixed(1) + 'B';
        if (views >= 1000000) return (views / 1000000).toFixed(1) + 'M';
        if (views >= 1000) return (views / 1000).toFixed(1) + 'K';
        return views.toString();
    },

    getVideoUrl: (streamInfo: StreamInfo): string | undefined => {
        if (streamInfo.hls) return streamInfo.hls;

        const streams = streamInfo.videoStreams || [];
        const combinedStreams = streams.filter(s => !s.videoOnly);

        if (combinedStreams.length > 0) {
            return combinedStreams.sort((a, b) => (b.height || 0) - (a.height || 0))[0]?.url;
        }

        return streams[0]?.url;
    },

    getCurrentInstance: (): string => currentInstance,
};

export default pipedApi;
